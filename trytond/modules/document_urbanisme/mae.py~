#coding: utf-8
"""
GPLv3
"""

from collections import OrderedDict
from datetime import date
import os

from osgeo import osr

from trytond.model import ModelView, ModelSingleton, ModelSQL, fields
from trytond.pyson import Bool, Eval, Not
from trytond.pool import PoolMeta, Pool
from trytond.report import Report

from trytond.modules.geotools.tools import get_as_epsg4326, bbox_aspect
from trytond.modules.map.map_render import MapRender
from trytond.modules.qgis.qgis import QGis

STATES = {
    'readonly': ~Eval('active', True),
}

DEPENDS = ['active']

class code(ModelSQL, ModelView):
    u"""Code"""
    __name__ = 'mae.code'
    _rec_name = 'name'

    code = fields.Char(
            string = u"""Code""",
            required = False,
            readonly = False,
        )

    name = fields.Char(
            string = u"""Short name of code""",
            required = False,
            readonly = False,
        )

    lib_long = fields.Char(
            string = u"""Label of code""",
            required = False,
            readonly = False,
        )

class geo_lieudit(ModelSQL, ModelView):
    u"""Lieu-dit"""
    __name__ = 'mae.geo_lieudit'
    _rec_name = 'tex'

    mae = fields.Many2One(
            'mae.mae',
            'mae',
            required=True
        )

    tex = fields.Char(
            string = u"""Short name of code""",
            required = False,
            readonly = False,
        )

    geom = fields.MultiPolygon(
            string=u"""Geometry""",
            help=u"""Geometry point (EPSG=2154, RGF93/Lambert 93)""",
            srid=2154,
        )

class geo_parcelle(ModelSQL, ModelView):
    u"""Parcelle"""
    __name__ = 'mae.geo_parcelle'
    _rec_name = 'tex'

    mae = fields.Many2One(
            'mae.mae',
            'mae',
            required=True
        )

    tex = fields.Char(
            string = u"""Short name of code""",
            required = False,
            readonly = False,
        )

    geom = fields.MultiPolygon(
            string=u"""Geometry""",
            help=u"""Geometry polygon (EPSG=2154, RGF93/Lambert 93)""",
            srid=2154,
        )

    @classmethod
    def __setup__(cls):
        super(geo_parcelle, cls).__setup__()
        cls._buttons.update({
            'geo_parcelle_edit': {},
        })

    @classmethod
    @ModelView.button_action('mae.report_geo_parcelle_edit')
    def geo_parcelle_edit(cls, ids):
        pass

class geo_parcelleQGis(QGis):
    __name__ = 'mae.geo_parcelle.qgis'
    TITLES = {'mae.geo_parcelle': u'Parcelle'}

class geo_section(ModelSQL, ModelView):
    u"""Section"""
    __name__ = 'mae.geo_section'
    _rec_name = 'tex'

    mae = fields.Many2One(
            'mae.mae',
            'mae',
            required=True
        )

    tex = fields.Char(
            string = u"""Short name of code""",
            required = False,
            readonly = False,
        )

    geom = fields.MultiPolygon(
            string=u"""Geometry""",
            help=u"""Geometry polygon (EPSG=2154, RGF93/Lambert 93)""",
            srid=2154,
        )

class diagno(ModelSQL, ModelView):
    u"""diagno"""
    __name__ = 'mae.diagno'

    mae = fields.Many2One(
            'mae.mae',
            'Mae',
            required=True,
            readonly=True,
        )

    ilot = fields.Char(            
            string = 'Ilot',
            help = u'PAC Ilot number at this expertise date',
            required=True,
        )

    date = fields.Date(
            string = 'Date', 
            help = 'Date of diagno',
        )    

    owner = fields.Many2One(
            'party.party',
            string='Owner',
            required=True,
            ondelete='RESTRICT',
            domain=[('categories', 'child_of', 1, 'parent')]
        )

    parcelle = fields.Many2Many(
            'mae.diagno-mae.parcelle',
            'diagno',
            'parcelle',
            string = 'Plot',            
        )

    typemae = fields.Char(            
            string = u'Type MAE',
            help = u'Niveau MAE demandé par l’exploitant',
        )

    nivexpert = fields.Char(            
            string = u'Expert',
            help = u'Niveau préconisé par l’expert',
        )

    nivfinal = fields.Char(            
            string = u'Final',
            help = u'Niveau pris au final',
        )

    paturage = fields.Boolean(
            string=u'Pâturage',
            help=u'Pâturage',
        )

    periodePat = fields.Char(
            string=u'Période(s)',	
            help=u'Période(s) de pâturage',
            states={'invisible': Not(Bool(Eval('paturage')))},
        )

    surfacePat = fields.Float(
            string='Surface',	
            help=u'Surface paturée (ha)',
            states={'invisible': Not(Bool(Eval('paturage')))},	
        )

    chargementMoyenPat = fields.Float(
            string='Moyen',	
            help=u'Chargement moyen (UGB/ha)',
            states={'invisible': Not(Bool(Eval('paturage')))},	
        )

    chargementInstantanePat = fields.Float(
            string=u'Instantané',	
            help=u'Chargement instantané (UGB/ha)',
            states={'invisible': Not(Bool(Eval('paturage')))},	
        )

    naturePat = fields.Selection([
            ('bovins', u'Bovins'),
            ('ovins', u'Ovins'),
            ('equins', u'Équins')],
            string='Nature',
            help=u'Nature',
            states={'invisible': Not(Bool(Eval('paturage')))},	
        )

    pratiquesPat = fields.Selection([
            ('deprimage', u'Déprimage'),
            ('regain', u'Regain')],
            string='Pratiques',
            help=u'Pratiques',
            states={'invisible': Not(Bool(Eval('paturage')))},
        )

    observationPat = fields.Text(
            string=u'Observations',
            help=u'Observations',
            states={'invisible': Not(Bool(Eval('paturage')))},
        )

    fauche = fields.Boolean(
            string=u'Fauche',
            help=u'Fauche',
        )    

    nombreFau = fields.Float(
            string='Nombre',	
            help=u'Nombre de fauche',
            states={'invisible': Not(Bool(Eval('fauche')))},	
        )

    dateFau = fields.Date(
            string=u'Date',	
            help=u'Date de fauche',
            states={'invisible': Not(Bool(Eval('fauche')))},
        )

    surfaceFau = fields.Float(
            string='Surface',	
            help=u'Surface de fauche',
            states={'invisible': Not(Bool(Eval('fauche')))},	
        )

    typeFau = fields.Selection([
            ('centrifuge', u'Centrifuge'),
            ('centripete', u'Centripète'),
            ('bande', u'Par bande'),
            ('autre', u'Autre')],
            string='Type',
            help=u'Type de fauche',
            states={'invisible': Not(Bool(Eval('fauche')))},	
        )

    sympaFau = fields.Boolean(
            string=u'Sympa',
            help=u'Sympa avec bande de bordure',
            states={'invisible': Not(Bool(Eval('fauche')))},
        )


    observationFau = fields.Text(
            string=u'Observations',
            help=u'Observations',
            states={'invisible': Not(Bool(Eval('fauche')))},
        ) 

    gestionPatFau = fields.Boolean(
            string=u'Mixte',
            help=u'Gestion mixte Fauche/Pâturage',
        )

    occupation = fields.Boolean(
            string=u'Occupation des sols',
            help=u'Autres types d''occupation des sols',
        )

    natureOcc = fields.Selection([
            ('friche', u'Friche'),
            ('boisement', u'Boisement'),
            ('autres', u'Autres')],
            string='Type',
            help=u'Type de fauche',
            states={'invisible': Not(Bool(Eval('occupation')))},
            on_change_with=['occupation']	
        )

    def on_change_with_natureOcc(self):
        if self.occupation is None:
            return ''
       
    autreOcc = fields.Text(
            string=u'Autres',
            help=u'Autres nature',
            states={'invisible': Not(Bool(Eval('occupation'))) and Eval('natureOcc') != 'autres'},            
        )

    pourcentageOcc = fields.Integer(
            string='Pourcentage',	
            help=u'Pourcentage de la parcelle concernée',
            states={'invisible': Not(Bool(Eval('occupation')))},	
        )

    observationOcc = fields.Text(
            string=u'Observations',
            help=u'Observations',
            states={'invisible': Not(Bool(Eval('occupation')))},
        )

    engrais = fields.Boolean(
            string=u'Engrais',
            help=u'Engrais',
        )

    mineraleEng = fields.Boolean(            
            string=u'Minéral',
            help=u'Minérale N,P,K',
            states={'invisible': Not(Bool(Eval('engrais')))},	
        )

    NEng = fields.Integer(
            string='N',	
            help=u'Pourcentage de N',
            states={'invisible': Not(Bool(Eval('mineraleEng')))},	
        )

    PEng = fields.Integer(
            string='P',	
            help=u'Pourcentage de P',
            states={'invisible': Not(Bool(Eval('mineraleEng')))},	
        )

    KEng = fields.Integer(
            string='K',	
            help=u'Pourcentage de K',
            states={'invisible': Not(Bool(Eval('mineraleEng')))},	
        )

    organicEng = fields.Boolean(            
            string=u'Organique',
            help=u'Organisue',
            states={'invisible': Not(Bool(Eval('engrais')))},	
        )

    natureEng = fields.Text(
            string=u'Nature',
            help=u'Nature des produits',
            states={'invisible': Not(Bool(Eval('engrais'))) and Not(Bool(Eval('organicEng')))},            
        )

    observationEng = fields.Text(
            string=u'Observations',
            help=u'Observations',
            states={'invisible': Not(Bool(Eval('engrais')))},
        )

    cloture = fields.Many2Many(
            'mae.diagno-mae.cloture',
            'diagno',
            'code',
            string = 'Cloture',
            domain=[('code', '=', 'CLO')],
        )

    utilisation = fields.Many2Many(
            'mae.diagno-mae.utilisation',
            'diagno',
            'code',
            string = 'Utilisation',
            domain=[('code', '=', 'UTI')],
        )

    entretien = fields.Many2Many(
            'mae.diagno-mae.entretien',
            'diagno',
            'code',
            string = 'Entretien',
            domain=[('code', '=', 'ENT')],
        )

    observation = fields.Text('Observations')

    photo = fields.Binary('Photo')

    active = fields.Boolean('Active')

    @staticmethod
    def default_active():
        return True    

class diagnoParcelle(ModelSQL):
    'diagno - Parcelle'
    __name__ = 'mae.diagno-mae.parcelle'
    _table = 'diagno_parcelle_rel'
    diagno = fields.Many2One('mae.diagno', 'diagno', ondelete='CASCADE',
            required=True)
    parcelle = fields.Many2One('mae.geo_parcelle', 'parcelle',
        ondelete='CASCADE', required=True)

class diagnoCloture(ModelSQL):
    'diagno - Cloture'
    __name__ = 'mae.diagno-mae.cloture'
    _table = 'diagno_cloture_rel'
    diagno = fields.Many2One('mae.diagno', 'diagno', ondelete='CASCADE',
            required=True)
    code = fields.Many2One('mae.code', 'code',
        ondelete='CASCADE', required=True)

class diagnoUtilisation(ModelSQL):
    'diagno - Utilisation'
    __name__ = 'mae.diagno-mae.utilisation'
    _table = 'diagno_utilisation_rel'
    diagno = fields.Many2One('mae.diagno', 'diagno', ondelete='CASCADE',
            required=True)
    code = fields.Many2One('mae.code', 'code',
        ondelete='CASCADE', required=True)

class diagnoEntretien(ModelSQL):
    'diagno - Entretien'
    __name__ = 'mae.diagno-mae.entretien'
    _table = 'diagno_entretien_rel'
    diagno = fields.Many2One('mae.diagno', 'diagno', ondelete='CASCADE',
            required=True)
    code = fields.Many2One('mae.code', 'code',
        ondelete='CASCADE', required=True)

class maeProtection(ModelSQL):
    'mae - protectionArea'
    __name__ = 'mae.diagno-protection.area'
    _table = 'mae_protection_area_rel'
    mae = fields.Many2One('mae.mae', 'mae', ondelete='CASCADE',
            required=True)
    status = fields.Many2One('protection.area', 'status',
        ondelete='CASCADE', required=True)

class mae(ModelSQL, ModelView):
    u"""mae"""
    __name__ = 'mae.mae'
    _rec_name = 'name'

    name = fields.Char(            
            string = 'Ilot',
            help = u'PAC Ilot number',
            required=True,
            states=STATES,
            depends=DEPENDS
        )

    commune = fields.Many2One(
            'town_fr.town_fr',
            string='Commune',
            help='Commune',
            required=True,
            ondelete='RESTRICT'
        )

    section = fields.One2Many(
            'mae.geo_section',
            'mae',
            string='Section',
        )

    lieudit = fields.One2Many(
            'mae.geo_lieudit',
            'mae',
            string='Lieu-dit',
        )
    
    parcelle = fields.One2Many(
            'mae.geo_parcelle',
            'mae',
            string='Plot',
            help='Cadastral plot'
        )

    surface = fields.Numeric(            
            string='Surface',
            help='Surface',
        )

    status = fields.Many2Many(
            'mae.diagno-protection.area',
            'mae',
            'status',
            string='Protection status',
            help='Protection status'
        )

    diagno = fields.One2Many(
            'mae.diagno',
            'mae',
            string='Diagnostic',
        )

    active = fields.Boolean('Active')    

    situation_map = fields.Binary('Situation map', filename='situation_filename')
    situation_filename = fields.Function(fields.Char('Filename', readonly=True, depends=['name']), '_get_sm_filename')

    image_map = fields.Binary('Image map', filename='image_filename')
    image_filename = fields.Function(fields.Char('Filename', readonly=True, depends=['name']), '_get_im_filename')      

    @staticmethod
    def default_active():
        return True
        
    COLOR = (1, 0.1, 0.1, 1)
    BGCOLOR = (1, 0.1, 0.1, 0.1)

    @classmethod
    def __setup__(cls):
        super(mae, cls).__setup__()       
        cls._buttons.update({
            'situation_map_gen': {},
            'image_map_gen': {},
            'mae_edit': {},
        })
    
    def _get_sm_filename(self, ids):
        """Situation map filename"""
        return '%s - Situation map.jpg' % self.name

    def _get_im_filename(self, ids):
        """Image map filename"""
        return '%s - Image map.jpg' % self.name

    @classmethod
    @ModelView.button_action('mae.report_mae_edit')
    def mae_edit(cls, ids):
        """Open in QGis button"""
        pass

    @staticmethod
    def default_active():
        return True

    @classmethod
    @ModelView.button
    def situation_map_gen(cls, records):
        """Render the situation map"""        
        for record in records:

            town, envelope_town, area_town = get_as_epsg4326([record.commune.contour])

            # Récupère l'étendu de la zone de mae
            #EmpObj = Pool().get(self.__name__)
            #objs = EmpObj.search([('equipement', '=', self.equipement.id), ('ug', '=', self.ug.id), ('station', '=', self.station.id)])
            #points, _envelope, area = get_as_epsg4326([obj.geom for obj in objs])

            section, envelope_section, area_section = get_as_epsg4326([obj.geom for obj in record.section])
            lieudit, envelope_lieudit, area_lieudit = get_as_epsg4326([obj.geom for obj in record.lieudit])
            parcelle, envelope_parcelle, area_parcelle = get_as_epsg4326([obj.geom for obj in record.parcelle])
            
            # Léger dézoom pour afficher correctement les points qui touchent la bbox
            envelope = bbox_aspect(envelope_section, 640, 480)  

            if envelope is None:
                continue

            # Map title
            title = u'Plan de situation\n'
            title += date.today().strftime('%02d/%02m/%Y')
                               
            m = MapRender(1024, 768, envelope, True)
            # Ajoute le fond de carte
            m.add_bg()                     

            # Ajoute le contour de la commune
            m.plot_geom(town[0], None, u'Commune', color=(0, 0, 1, 1), bgcolor=(0, 0, 0, 0))
                
            # Ajoute la section
            m.plot_geom(section[0], None, u'Section', color=(0, 0, 1, 0.3), bgcolor=(0, 0, 1, 0.3))

            # Ajoute le lieud dit
            m.plot_geom(lieudit[0], None, u'Lieu-dit', color=(0, 1, 1, 0.3), bgcolor=(0, 1, 1, 0.3))

            # Ajoute la pracelle
            m.plot_geom(parcelle[0], record.name, u'Parcelle', color=cls.COLOR, bgcolor=cls.BGCOLOR) 
            
            data_nl = m.render()
            m.plot_legend()
            m.plot_compass()
            m.plot_scaling()
            m.plot_title(title)
            data = m.render()
            cls.write([record], {'situation_map': buffer(data)})

    @classmethod
    @ModelView.button
    def image_map_gen(cls, records):
        """Render the image map"""        
        for record in records:
            # Récupère l'étendu de la zone de mae            
            parcelle, _envelope, _area = get_as_epsg4326([record.parcelle.geom])
            
            # Léger dézoom pour afficher correctement les points qui touchent la bbox
            envelope = [
                _envelope[0] - 0.001,
                _envelope[1] + 0.001,
                _envelope[2] - 0.001,
                _envelope[3] + 0.001,
            ]  

            if envelope is None:
                continue                                           
            
             # Map title
            title = u'Plan local\n'
            title += date.today().strftime('%02d/%02m/%Y')


            m = MapRender(1024, 768, envelope, True)
            # Ajoute le fond de carte
            m.add_bg()            

            # Ajoute la pracelle
            m.plot_geom(parcelle[0], record.name, u'Parcelle', color=cls.COLOR, bgcolor=cls.BGCOLOR) 
            
            data_nl = m.render()
            m.plot_legend()
            m.plot_compass()
            m.plot_scaling()
            m.plot_title(title)
            data = m.render()
            cls.write([record], {'image_map': buffer(data)})

class maeQGis(QGis):
    __name__ = 'mae.mae.qgis'
    FIELDS = OrderedDict([
        ('parcelle', None),
    ])
    TITLES = {
        'mae.mae': u'mae',
        'mae.geo_parcelle': u'Parcelle',        
    }
